#!/usr/bin/env python3

import rospy
import numpy as np
import time
import tf

from threading import Lock, Thread
from nav_msgs.msg import Odometry, Path
from geometry_msgs.msg import Twist, PoseWithCovarianceStamped
from sensor_msgs.msg import LaserScan 


def timed(func):
    def wrapper(*args):
        if not log_times:
            return func(*args)
        time_start = time.time()
        out = func(*args)
        time_end = time.time()
        time_took = time_end - time_start
        rospy.loginfo('Method {} from dwa took {}s.'.format(func.__name__, time_took))
        return out
    return wrapper

def threaded(fn):
    def wrapper(*args):
        Thread(target=fn, args=args).start()
    return wrapper


# simplified motion model of the rto
def motion(x, y, yaw, v, w, dt):
    # make more robust
    if w == 0:
        xn = x + (v * np.cos(yaw) * dt)
        yn = y + (v * np.sin(yaw) * dt)
        yawn = yaw
    else:
        xn = x + (v/w) * (- (np.sin(yaw) + np.sin(yaw + w * dt)))
        yn = y + (v/w) * ((np.cos(yaw) - np.cos(yaw + w * dt)))
        yawn = yawn + dt * w  
    return xn, yn, yawn


class DWALocalPlanner():

    def __init__(self, freq):

        # Init mutex
        self.lock = Lock()

        # Get params from parameter server
        self.min_lin_vel = rospy.get_param('~min_linear_vel')
        self.max_lin_vel = rospy.get_param('~max_linear_vel')
        self.min_ang_vel = rospy.get_param('~min_angular_vel')
        self.max_ang_vel = rospy.get_param('~max_angular_vel')
        self.max_acc = rospy.get_param('~max_acc')
        self.res_ang_vel_space = rospy.get_param('~res_ang_vel_space')
        self.res_lin_vel_space = rospy.get_param('~res_lin_vel_space')
        self.gain_vel = rospy.get_param('~gain_vel')
        self.gain_prox_to_path = rospy.get_param('~gain_glob_path')
        self.gain_angle_to_goal = rospy.get_param('~gain_goal_angle')
        self.gain_prox_to_obst = rospy.get_param('~gain_clearance')


        # Init subscriptions
        rospy.Subscriber('/odom', Odometry, self._cb_current_twist)
        rospy.Subscriber('/global_path', Path, self._cb_global_path)
        rospy.Subscriber('/amcl_pose', PoseWithCovarianceStamped, self._cb_current_pose)
        # local costmap or scan or just map for testing
 
        # Init publisher
        rospy.Publisher('/cmd_vel', Twist, queue_size=10)
  
        # Setup messages for publishing
        self.twist = Twist()
        self.twist.linear.z = 0
        self.twist.angular.x = 0
        self.twist.angular.y = 0

        # Init instance variables
        self.dt = 1/freq
        self.current_pose = (0, 0, 0)
        self.current_twist = (1, 0, 0.25)
        self.global_path = []



    def _cb_current_pose(self, msg):
        quaternion = (msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, \
            msg.pose.pose.orientation.z, msg.pose.pose.orientation.w,)
        euler = tf.transformations.euler_from_quaternion(quaternion)
        self.lock.acquire()
        self.current_pose = (msg.pose.pose.position.x, msg.pose.pose.position.y, euler[2])
        self.lock.release()

    def _cb_current_twist(self, msg):
        self.lock.acquire()
        self.current_twist = (msg.twist.twist.linear.x, msg.twist.twist.linear.y, msg.twist.twist.angular.z)
        self.lock.release()

    def _cb_global_path(self, msg):
        self.lock.acquire()
        self.global_path.clear()
        for pose in msg.poses:
            self.global_path.append((pose.pose.position.x, pose.pose.position.y))
        rospy.loginfo('Local planner reveived a global path')
        self.lock.release()

    
    # TODO: think about use of half the velocity since when accelerating, the mean should be taken.
    def _get_dynamic_window(self):
        lin_vel = self.current_twist[0]
        ang_vel = self.current_twist[2]
        dt = self.dt

        # Set velocity space that is reachable for the robot based on current velocity and max. acceleration
        # and check if the maximal velocity boundaries are crossed. 
        if (lin_vel + self.max_acc * dt) > self.max_lin_vel:
            lin_vel_space = np.linspace(lin_vel - self.max_acc * dt, self.max_lin_vel, self.res_lin_vel_space)
        elif (lin_vel - self.max_acc * dt) < self.min_lin_vel:
            lin_vel_space = np.linspace(self.min_lin_vel, lin_vel + self.max_acc * dt, self.res_lin_vel_space)
        else:
            lin_vel_space = np.linspace(lin_vel - self.max_acc * dt, lin_vel + self.max_acc * dt, self.res_lin_vel_space)

        if (ang_vel + self.max_acc * dt) > self.max_ang_vel:
            ang_vel_space = np.linspace(ang_vel - self.max_acc * dt, self.max_ang_vel, self.res_ang_vel_space)
        elif (ang_vel - self.max_acc * dt) < self.min_ang_vel:
            ang_vel_space = np.linspace(self.min_ang_vel, ang_vel + self.max_acc * dt, self.res_ang_vel_space)
        else:
            ang_vel_space = np.linspace(ang_vel - self.max_acc * dt, ang_vel + self.max_acc * dt, self.res_ang_vel_space)

        # Make use of np.meshgrid to get an array containing all the samples that have been discretely sampled from the Vd control space
        xv, yv = np.meshgrid(ang_vel_space, lin_vel_space)
        Vd = np.empty((self.res_lin_vel_space, self.res_ang_vel_space), dtype='float32, float32')
        
        for i in range(self.res_lin_vel_space):
            for j in range(self.res_lin_vel_space):
                Vd[i,j] = (xv[i,j], yv[i,j])

        return Vd


    # TODO: Implement these methods
    def _get_cost(self, pos):
        '''
        cost_vel = self._get_vel_cost()
        cost_prox_to_path = self._get_prox_to_path_cost()
        cost_angle_to_goal = self._get_angle_to_goal_cost()
        cost_prox_to_obst = self._get_prox_to_obst_cost()
        
        return (self.gain_vel * cost_vel + self.gain_prox_to_path * cost_prox_to_path +\
            self.gain_angle_to_goal * cost_angle_to_goal + self.gain_prox_to_obst * cost_prox_to_obst)
        '''






    def run(self):
        while not rospy.is_shutdown():

            Vd = self._get_dynamic_window()



            # Uncomment for debugging or testing
            #print(Vd[0,0], Vd[0,-1], Vd[-1,0], Vd[-1,-1])
            
            rospy.sleep(self.dt)



'''
- motion model
- get dynamic window
- predict trajectory and control
- set costs


Basic algoritm idea:
- Discretely sample in the robot's control space (dx,dy,dtheta)
- For each sampled velocity, perform forward simulation from the robot's current state to predict what would happen if the sampled velocity were applied for some (short) period of time.
- Evaluate (score) each trajectory resulting from the forward simulation, using a metric that incorporates characteristics such as: proximity to obstacles, proximity to the goal, proximity to the global path, and speed. Discard illegal trajectories (those that collide with obstacles).
- Pick the highest-scoring trajectory and send the associated velocity to the mobile base.
- Rinse and repeat.
'''





if __name__ == '__main__':
    log_times = True

    rospy.init_node('local_planner')

    local_planner = DWALocalPlanner(2)
    local_planner.run()


'''
    @timed
    def _get_Vs(self):
        ang_vel_axis = np.linspace(self.min_ang_vel, self.max_ang_vel, self.res_ang_vel_space)
        lin_vel_axis = np.linspace(self.min_lin_vel, self.max_lin_vel, self.res_lin_vel_space)
        xv, yv = np.meshgrid(ang_vel_axis, lin_vel_axis)

        Vs = np.empty((self.res_lin_vel_space, self.res_ang_vel_space), dtype='float32, float32')
        
        for i in range(self.res_lin_vel_space):
            for j in range(self.res_lin_vel_space):
                Vs[i,j] = (xv[i,j], yv[i,j])
        return Vs
    '''
