#!/usr/bin/env python3
import rospy
import tf
import tf2_ros
import tf.transformations as transform
from std_msgs.msg import ColorRGBA
from nav_msgs.msg import OccupancyGrid, Odometry
from geometry_msgs.msg import TransformStamped, PoseStamped
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from math import cos, sin, pi, inf, exp, sqrt
from threading import Lock
import random
import numpy as np
from matplotlib import pyplot as plt
from timeit import default_timer as timer
import cProfile, pstats, io
import os, psutil
import sys
import cv2


from rto_map_server.srv import GetMap

class Particle(object):
    def __init__(self, id, x, y, yaw):
        self.x = x
        self.y = y
        self.id = id
        self.yaw = yaw

class ParticleFilter(object):
    def __init__(self, num_particles, occ_grid_map,
                 laser_min_range, laser_max_range, laser_min_angle, laser_max_angle, subsampled_angles, eval_beams, 
                 dynamics_translation_noise_std_dev,
                 dynamics_orientation_noise_std_dev, odom_noise):

        #Particle Filter variables
        self.num_particles = num_particles
        self.eval_beams = eval_beams
        self.odom_noise = odom_noise
        self.particles = np.empty(self.num_particles, dtype=Particle)
        self.weights = np.array([1/self.num_particles]*self.num_particles)

        # Occupancy grid map from map server
        self.ogm = occ_grid_map
        self.ogm_map = np.transpose(np.asarray(occ_grid_map.map.data, dtype=np.int8).reshape(occ_grid_map.map.info.height, occ_grid_map.map.info.width))
        self.ogm_map[self.ogm_map==-1]=100

        # Occupancy Grid map parameter
        self.xmin = 0
        self.xmax = occ_grid_map.map.info.width-1
        self.ymin = 0
        self.ymax = occ_grid_map.map.info.height-1
        self.resolution = occ_grid_map.map.info.resolution

        # laser setup
        self.laser_max_angle = laser_max_angle
        self.laser_min_angle = laser_min_angle
        self.laser_max_range = laser_max_range
        self.laser_min_range = laser_min_range
        self.subsampled_angles = subsampled_angles

        # Relative motion since the last time particles were predicted
        self.dx = 0
        self.dy = 0
        self.dyaw = 0

        # uncertainty for dynamic model
        self.dynamics_translation_noise_std_dev = dynamics_translation_noise_std_dev
        self.dynamics_orientation_noise_std_dev = dynamics_orientation_noise_std_dev

    def ogm_to_map(self, x_ogm, y_ogm, yaw_ogm):
        """
        Public method: Transforms positions in the Occupancy Grid Map which is 0,0 in bottom left corner to coordinates to /map coordinate frame

        @param x_ogm: x position in Occupancy Grid Map 
        @param y_ogm: y position in Occupancy Grid Map
        @param yaw_ogm: yaw in Occupancy Grid Map
        """

        x = x_ogm + self.ogm.map.info.origin.position.x
        y = y_ogm + self.ogm.map.info.origin.position.y
        _, _, yaw_map = transform.euler_from_quaternion(np.array([self.ogm.map.info.origin.orientation.x, self.ogm.map.info.origin.orientation.y, self.ogm.map.info.origin.orientation.z, self.ogm.map.info.origin.orientation.w]))
        yaw = yaw_ogm + yaw_map

        return x, y, yaw

    def _grid_to_continous(self, x_grid, y_grid):
        """
        Private Method: Transforms x, y postions in Occupancy Grid Map in continous x, y values

        @param x_grid: x position in Occupancy Grid Map 
        @param y_grid: y position in Occupancy Grid Map
        """
        x_continous = x_grid*self.resolution
        y_continous = y_grid*self.resolution
        return x_continous, y_continous

    def _continous_to_grid(self, x_continous, y_continous):
        """
        Private Method: Transforms continous x, y values to x, y postions in Occupancy Grid Map 

        @param x_grid: x position in Occupancy Grid Map 
        @param y_grid: y position in Occupancy Grid Map
        """
        grid_x_in_xrange = int(round(x_continous/self.resolution))
        grid_y_in_yrange = int(round(y_continous/self.resolution))
        return grid_x_in_xrange, grid_y_in_yrange

    def _find_lost_robot(self):
        """
        Privat Method: Samples continous x,y, yaw positions randomly in the free space in order to find lost robot
        """

        while True:
            x_grid = int(np.random.uniform(self.xmin, self.xmax))
            y_grid = int(np.random.uniform(self.ymin, self.ymax))
            yaw = int(np.random.uniform(-pi, pi))

            # sample particle if it is in free space
            if self.ogm_map[x_grid, y_grid] != 100:
                break

        x, y = self._grid_to_continous(x_grid, y_grid)

        return x, y, yaw

    def _get_random_free_space(self):
        """
        Private Method: Samples continous x,y, yaw positions in the free space close to the init position of robot
        """

        while True:

            x = np.random.uniform(-self.ogm.map.info.origin.position.x*0.9, -self.ogm.map.info.origin.position.x*1.1)
            y = np.random.uniform(-self.ogm.map.info.origin.position.y*0.9, -self.ogm.map.info.origin.position.y*1.1)
            _, _, yaw_map = transform.euler_from_quaternion(np.array([self.ogm.map.info.origin.orientation.x, self.ogm.map.info.origin.orientation.y, self.ogm.map.info.origin.orientation.z, self.ogm.map.info.origin.orientation.w]))
            yaw = np.random.uniform(-yaw_map*0.7, -yaw_map*1.3)
            
            # sample particle if it is in free space
            x_grid, y_grid = self._continous_to_grid(x,y)
            if self.ogm_map[x_grid, y_grid] != 100:
                break

        return x, y, yaw

    def init_particles(self, type):
        """
        Public Method: function which initilizes the particles

        @param type: defines whether particles are initialized randomly ("rand") or close to to the init position of robot ("init")
        """

        for i in range(self.num_particles):
            if type == "init":
                x, y, yaw = self._get_random_free_space()
            else:
                x, y, yaw = self._find_lost_robot()
            particle = Particle(i, x, y, yaw)
            self.particles[i] = particle



    def handle_observation(self, laser_scan_msg): #time = 0.6
        """
        Public Method: Predicts and updates the particles

        @param laser_scan_message: laser scan message which is used for update of particles
        """
        weights_not_normalized = np.zeros((self.num_particles))
        
        # calculate weights
        for i in range(self.num_particles):
            self.particles[i].x, self.particles[i].y, self.particles[i].yaw = self._predict_odometry(self.particles[i])
            error = self._get_prediction_error(laser_scan_msg, self.particles[i])
            weights_not_normalized[i] = exp(-error)

        #commulated relative motion between 2 consecutive prediction set to 0
        self.dx = 0
        self.dy = 0
        self.dyaw = 0

        # normalize weights
        weights_new = [i/sum(weights_not_normalized) for i in weights_not_normalized]
        self.weights = weights_new.copy()

        #resample
        self._resample()

    def _resample(self): #time = 0.0003
        """
        Private Method: Resamples the set of particles (importance sampling)
        """

        new_particles = np.empty(self.num_particles, dtype=Particle)
        index = random.randint(0,self.num_particles-1)
        max_weight = max(self.weights)
        beta = 0

        # resample particles with a probability according to their weight
        for i in range(self.num_particles):
            beta += random.uniform(0, 2*max_weight)

            while self.weights[index] < beta:
                beta -= self.weights[index]

                if (index+1) <= (self.num_particles-1):
                    index += 1
                else:
                    index = 0

            particle = self.particles[index]
            new_particle = Particle(i, particle.x, particle.y, particle.yaw)
            new_particles[i] = new_particle

        self.particles = new_particles.copy()

    def _get_occupied_cell_vec(self,x,y):
        """
        Private Method: Return values for all cells which would be sensed by the laser scanner of a robot in the pose of the particle 

        @params x: Vector containing x positions of the relevant cells
        @params y: Vector containing y positions of the relevant cells
        """
        
        cells = np.array([x,y]).T

        # return value 200 for all cells outside of map boundary
        mask = (cells[:,0]>=self.xmin)&(cells[:,0]<=self.xmax)&(cells[:,1]>=self.ymin)&(cells[:,1]<=self.ymax)
        result=np.zeros(mask.shape)
        result[mask==False]=200

        # return stored value for all cells within the map boundary
        result[mask==True]=self.ogm_map[cells[mask==True,0], cells[mask==True,1]]

        return result

    def _get_laser_scan_for_particle(self, x, y, yaw): # time = 0.006
        """
        Private Method: Simulate the laser scan of the robot, if it is located in particle pose (x,y,yaw):
                        - Take x, y, yaw pose of particle and sense the surrounding
                        - Sense in the directions of subsampled angles
                        - Sense in the range of minimal to maximal distance of laser in steps of map resolution
        
        @ param x: x position of particle
        @ param y: y position of particle
        @ param yaw: yaw orientation of partcile
        """
        # calculate vectors containing all sin, cos values and distances to calculate relevant cells around particle
        particle_ranges = np.zeros((self.eval_beams))
        angles = np.array(self.subsampled_angles) + yaw # total angle = angle of robot position + laser angle
        sin_angles = np.sin(angles)
        cos_angles = np.cos(angles)
        distances = np.arange(0,self.laser_max_range, self.resolution)

        # x,y values of relevant cells (axis=0: distances, axis=1: sin, cos angles)
        x_values = np.multiply.outer(distances, cos_angles)+x
        y_values = np.multiply.outer(distances, sin_angles)+y
        assert(x_values.shape==(distances.size,cos_angles.size) and y_values.shape==(distances.size,sin_angles.size))
        x_values_grid = (x_values/self.resolution).astype(int)
        y_values_grid = (y_values/self.resolution).astype(int)

        # flatten array as vector which can be fed into _get_occupied_cell_vec
        x_values_grid_vector = x_values_grid.flatten()
        y_values_grid_vector = y_values_grid.flatten()
        assert(x_values_grid_vector.size == distances.size*cos_angles.size and y_values_grid_vector.size == distances.size*sin_angles.size)

        # for each x,y position get information about cell (cell out of map = 200, occupied cell = 100, free cell = 0)
        occupied_info_vector = self._get_occupied_cell_vec(x_values_grid_vector, y_values_grid_vector)
        assert(occupied_info_vector.size == distances.size*cos_angles.size)
        occupied_info_array = occupied_info_vector.reshape(x_values.shape).astype(float)

        # get distance of occupied cell to robot
        occupied_info_array[np.where(occupied_info_array==100)]=np.where(occupied_info_array==100)[0]*self.resolution

        # cells with distance values smaller than laser_min_range have distance laser_min_range
        occupied_info_array[(occupied_info_array>0) & (occupied_info_array<=self.laser_min_range)]=self.laser_min_range 

        #replace all cells which are out of map with laser_max_range
        occupied_info_array[occupied_info_array==200]=self.laser_max_range

        # for each angle get value which laserscaner of robot would return
        for i in range(particle_ranges.size):
            if np.any(occupied_info_array[:,i]==self.laser_min_range): #obstacle in laser_min_range distance
                particle_ranges[i] = self.laser_min_range
            elif np.all(occupied_info_array[:,i]==0): # no obstacle sensed
                particle_ranges[i] = self.laser_max_range
            else: # distance fo senses obstacle
                particle_ranges[i] = np.min(occupied_info_array[:,i][np.nonzero(occupied_info_array[:,i])])

        return particle_ranges


    def _subsample_laser_scan(self, laser_scan_msg): #time = 0.0001
        """
        Private Method: - Subsample laserscans from the whole range of the hokuyo laserscaner
                        - angles are defined by subsampled_angles and eval_beams
                        - replace value inf of laser scanner with max range of laser scanner
        
        @ params laser_scan_msg: laser scan message which will be subsampled
        """

        subsampled_ranges = []
        subsampled_angles_index = np.linspace(0, len(laser_scan_msg.ranges)-1, self.eval_beams).astype(int)

        for i in range(self.eval_beams):
            if laser_scan_msg.ranges[subsampled_angles_index[i]] == inf:
                subsampled_ranges.append(self.laser_max_range)
            else:
                subsampled_ranges.append(laser_scan_msg.ranges[subsampled_angles_index[i]])

        return subsampled_ranges



    def _get_prediction_error(self, laser_scan_msg, particle): #time = 0.003
        """
        Private Method: Calculate the laser scan error between particles and robot
        
        @params laser_scan_msg: laser scan message from robot which is compared with the simulated laser scan of particle (laser scan of robot if it 
                                has same pose as particle)
        @params particle: particle for which the error is caclulated
        """

        # high error for particles outside of ogm or within an obstacle
        x_grid, y_grid = self._continous_to_grid(particle.x, particle.y)
        if x_grid < self.xmin or x_grid > self.xmax or y_grid < self.ymin or y_grid > self.ymax or (self.ogm_map[x_grid, y_grid] == 100):
            error = 3000
        else:
            # mean squared error between robot and particle laser_scan
            subsampled_ranges = self._subsample_laser_scan(laser_scan_msg)
            particle_ranges = self._get_laser_scan_for_particle(particle.x, particle.y, particle.yaw)
            diff_ranges = np.abs(np.array(subsampled_ranges)-np.array(particle_ranges))
            norm_error = np.linalg.norm(diff_ranges)
            error = pow(norm_error,2)
        return error


    def handle_odometry(self, odom, last_odom): #time = 0.0001
        """
        Public Method: Calculates the difference between two odometry messages used in two consecutive predictions

        @params odom: odometry message used in current prediction
        @params last_odom: odometry message used in last prediction
        """

        position = np.array([odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z])
        last_position = np.array([last_odom.pose.pose.position.x, last_odom.pose.pose.position.y, last_odom.pose.pose.position.z])
        orientation = np.array([odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w])
        last_orientation = np.array([last_odom.pose.pose.orientation.x, last_odom.pose.pose.orientation.y, last_odom.pose.pose.orientation.z, last_odom.pose.pose.orientation.w])

        # diff yaw (current orientation * inverse last orientation)
        diff_orientation_quaternion = transform.quaternion_multiply(transform.quaternion_inverse(last_orientation), orientation)
        _, _, yaw_diff = transform.euler_from_quaternion(diff_orientation_quaternion) #clockwise rotation is negative

        # diff x,y position
        diff_position = position-last_position

        # inlcude noise to odometry
        if self.odom_noise == True:
            diff_position += random.gauss(0, 0.1)*diff_position
    

        #add relative motion to commulated relativ motion which is used in next prediction
        self.dx = diff_position[0]
        self.dy = diff_position[1]
        self.dyaw = yaw_diff

    def _predict_odometry(self, particle): #time = 1e-5
        """
        Private Method: Predict particle according to odometry and incorperate uncertainty

        @params particle: particle which will be predicted
        """
        # uncertainty of odometry adapted to relative motion of robot to net let uncertainty dominate preediction
        nx = random.gauss(0, self.dynamics_translation_noise_std_dev) * (abs(self.dx) + abs(self.dy))
        ny = random.gauss(0, self.dynamics_translation_noise_std_dev) * (abs(self.dx) + abs(self.dy))
        nyaw = random.gauss(0, self.dynamics_orientation_noise_std_dev) * self.dyaw

        # predict particle according to odometry with  uncertainty
        x_new = particle.x + self.dx + nx
        y_new = particle.y + self.dy + ny
        if particle.yaw + self.dyaw + nyaw > pi:
            yaw_new = 2 * -pi + particle.yaw + self.dyaw + nyaw
        elif particle.yaw + self.dyaw + nyaw< -pi:
            yaw_new = 2* pi + particle.yaw + self.dyaw + nyaw
        else:
            yaw_new = particle.yaw + self.dyaw + nyaw

        return x_new, y_new, yaw_new

    def get_position(self):
        """
        Public Method: Return estimated pose of MCL localization as weighted average of all particles
        """
        
        length = len(self.weights)
        x_in, y_in, yaw_in = 0, 0, 0
        for i in range(length):
            x, y, yaw = self.ogm_to_map(self.particles[i].x, self.particles[i].y, self.particles[i].yaw)
            x_in += self.weights[i] * x
            y_in += self.weights[i] * y
            yaw_in += self.weights[i] * yaw

        # transform best particle pose from hokuyo link to base link (x = x_in-0.08)#time = 0.0005
        self.listener = tf.TransformListener()
        now = rospy.Time.now()
        self.listener.waitForTransform('/base_link', '/hokuyo_link', now, rospy.Duration(10.0))
        pose_msg = PoseStamped()
        pose_msg.header.frame_id = '/base_link'
        pose_msg.pose.position.x=x_in
        pose_msg.pose.position.y=y_in
        q = transform.quaternion_from_euler(0,0,yaw_in)
        pose_msg.pose.orientation.x = q[0]
        pose_msg.pose.orientation.y = q[1]
        pose_msg.pose.orientation.z = q[2]
        pose_msg.pose.orientation.w = q[3]
        new_pose = self.listener.transformPose('/hokuyo_link', pose_msg)
        x,y = new_pose.pose.position.x, new_pose.pose.position.y
        _, _, yaw = transform.euler_from_quaternion([new_pose.pose.orientation.x, new_pose.pose.orientation.y, new_pose.pose.orientation.z, new_pose.pose.orientation.w]) 

        return x, y, yaw

class MonteCarloLocalization(object):

    #initializes object of MonteCarloLocalization and sets all parameters
    def __init__(self):

        rospy.init_node('monte_carlo_localization')

        self.lock = Lock()

        #load map from map_loader_node
        rospy.wait_for_service('get_map')
        try:
            get_map = rospy.ServiceProxy('get_map', GetMap)
            self.ogm = get_map(1)
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)

        # set variables for prediction and measurement update
        self.odometry = None
        self.last_odometry = None
        self.odometry_list = np.empty(0)
        self.odometry_list_time = np.empty(0)
        self.odom_dict = {"time": [], "odom": []}
        
        self.observation = None

        #read in parameters from launch file
        dynamics_translation_noise_std_dev   = rospy.get_param("~dynamics_translation_noise_std_dev")
        dynamics_orientation_noise_std_dev   = rospy.get_param("~dynamics_orientation_noise_std_dev")
        self.eval_beams = rospy.get_param("~num_beams")
        num_particles = rospy.get_param("~num_particles")
        self.update_rate = rospy.get_param("~update_rate")
        odom_noise = rospy.get_param("~odom_noise")

        # instantiate ParticleFilter
        self.pf = ParticleFilter(num_particles, self.ogm, 0, 0, 0, 0, 0, self.eval_beams,
                                 dynamics_translation_noise_std_dev,
                                 dynamics_orientation_noise_std_dev, odom_noise)

        # initialize particles of pf
        self.pf.init_particles(type="init")

        # initialize broadcaster for TF
        self.br = tf2_ros.TransformBroadcaster()
        self.x_diff = None
        self.y_diff = None
        self.orientation_diff = None

        # Subscribers
        self.laser_sub = rospy.Subscriber('/scan', LaserScan, self._laser_scan_callback, queue_size=1) # 40hz
        self.odom_sub = rospy.Subscriber('/odom', Odometry,  self._odometry_callback, queue_size=10) #20hz
        self.global_costmap_sub = rospy.Subscriber('/global_costmap', OccupancyGrid, self._global_costmap_callback)


        # Publisher
        self.pub_particles = rospy.Publisher('/particles', MarkerArray, queue_size=1)
        self.pub_best_particle = rospy.Publisher('/particle', Marker, queue_size=1)
        self.pub_pos = rospy.Publisher('/pose', PoseStamped, queue_size=1)

    def _laser_scan_callback (self, msg):
        """
        Private Method: Callback function for laser scan Subsriber

        @params msg: Message of type LaserScan
        """
        self.lock.acquire()

        if self.observation == None: #first scan message
            # min, max of laser
            self.pf.laser_min_angle = msg.angle_min
            self.pf.laser_max_angle = msg.angle_max
            self.pf.laser_min_range = msg.range_min
            self.pf.laser_max_range = msg.range_max
            # subsampled laserscans
            subsampled_angles = np.linspace(msg.angle_min, msg.angle_max, self.eval_beams)
            self.pf.subsampled_angles = subsampled_angles

        self.observation = msg
        self.lock.release()

    def _odometry_callback(self, msg): #20hz
        """
        Private Method: Callback function for odometry Subsriber

        @params msg: Message of type Odometry
        """
        self.lock.acquire()
        self.odometry = msg
        self.odometry_list = np.append(self.odometry_list, msg)
        self.odometry_list_time = np.append(self.odometry_list_time, msg.header.stamp.to_sec())
        self.odom_dict["time"].append(msg.header.stamp.to_sec())
        self.odom_dict["odom"].append(msg)
        self.lock.release()

    def _global_costmap_callback(self, msg):
        """
        Private Method: Callback function for global costmap Subsriber

        @params msg: Message of type OccupancyGrid
        """
        self.lock.acquire()
        # update map with global costmap
        global_costmap = msg.data
        global_costmap = np.transpose(np.asarray(msg.data, dtype=np.int8).reshape(msg.info.height, msg.info.width))
        global_costmap[global_costmap!=100]=0
        self.pf.ogm_map=global_costmap
        self.lock.release()

    def _update_frame_transformation(self, odometry_for_tf):
        """
        Private Method: - Calculate the difference between pose estimated by MCL localization and robot pose calculated from odometry
                        - pose estimated by localization is in /map frame and pose calculated from odometry is in /odom frame
                        - The difference is used to create a TF between /map frame and /odom frame
                        - TF is calculated right after prediction and update of particles

        @params odometry_for_tf: odometry message with timestamp close to the timestamp of the scan message which is used to update the particles
        """

        x_Particle_Filter, y_Particle_Filter, yaw_Particle_Filter = self.pf.get_position()
        orientation_particle = transform.quaternion_from_euler(0, 0, yaw_Particle_Filter)

        # odometry pose
        x_Odometry = odometry_for_tf.pose.pose.position.x
        y_Odometry = odometry_for_tf.pose.pose.position.y
        orientation_odometry = (odometry_for_tf.pose.pose.orientation.x, odometry_for_tf.pose.pose.orientation.y, odometry_for_tf.pose.pose.orientation.z, odometry_for_tf.pose.pose.orientation.w)

        # difference between odometry and map
        self.x_diff = x_Particle_Filter-x_Odometry
        self.y_diff = y_Particle_Filter-y_Odometry
        self.orientation_diff = transform.quaternion_multiply(transform.quaternion_inverse(orientation_odometry), orientation_particle)

    def _broadcast_frame_transformation(self):
        """
        Private Method: Broadcast TF between /map and /odom frame
        """
        
        #broadcast TF
        broadcast_msg = TransformStamped()
        broadcast_msg.header.stamp = rospy.Time.now()
        broadcast_msg.header.frame_id = "map"
        broadcast_msg.child_frame_id = "odom"
        broadcast_msg.transform.translation.x = self.x_diff
        broadcast_msg.transform.translation.y = self.y_diff
        broadcast_msg.transform.translation.z = 0.0
        broadcast_msg.transform.rotation.x = self.orientation_diff[0]
        broadcast_msg.transform.rotation.y = self.orientation_diff[1]
        broadcast_msg.transform.rotation.z = self.orientation_diff[2]
        broadcast_msg.transform.rotation.w = self.orientation_diff[3]
        self.br.sendTransform(broadcast_msg)

    def _publish(self):
        """
        Private Method: - Visualize Particles in RVIZ
                        - Visualize best Particle in RVIZ
                        - Publish estimated pose of MCL localization
        """

        # publish all particles in red
        markerArray = MarkerArray()
        for particle in self.pf.particles:
            marker = Marker()
            marker.header.stamp = rospy.Time.now()
            marker.header.frame_id = 'map'
            marker.ns = 'particles'
            marker.id = particle.id
            marker.scale.x = 0.1
            marker.scale.y = 0.1
            marker.type = marker.ARROW
            marker.action = 0
            marker.lifetime = rospy.Duration(1)
            marker.color = ColorRGBA(1.0, 0.0, 0, 1.0)
            x_particle, y_particle, yaw_particle = self.pf.ogm_to_map(particle.x, particle.y, particle.yaw)
            marker.pose.position.x, marker.pose.position.y = x_particle, y_particle
            marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w = transform.quaternion_from_euler(0,0,yaw_particle) 
            marker.pose.position.z = 0.0
            markerArray.markers.append(marker)
        self.pub_particles.publish(markerArray)

        # publish the most accurate particle in green
        marker_best = Marker()
        marker_best.header.stamp = rospy.Time.now()
        marker_best.header.frame_id = 'map'
        marker_best.ns = 'particles'
        marker_best.id = 6
        marker_best.scale.x = 0.1
        marker_best.scale.y = 0.1
        marker_best.type = marker_best.ARROW  # arrow
        marker_best.action = 0 # add/modify
        marker_best.lifetime = rospy.Duration(1)
        marker_best.color = ColorRGBA(0.0, 1.0, 0, 1.0)
        x,y,yaw = self.pf.get_position()
        marker_best.pose.position.x, marker_best.pose.position.y = x,y
        marker_best.pose.position.z = 0.0
        marker_best.pose.orientation.x, marker_best.pose.orientation.y, marker_best.pose.orientation.z, marker_best.pose.orientation.w = transform.quaternion_from_euler(0,0,yaw) 
        self.pub_best_particle.publish(marker_best)

        # publish position to global planer
        pose = PoseStamped()
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = 'map'
        x,y,yaw = self.pf.get_position() #pose of best particle
        pose.pose.position.x, pose.pose.position.y = x,y
        pose.pose.position.z = 0.0
        pose.pose.orientation.x, pose.pose.orientation.y, pose.pose.orientation.z, pose.pose.orientation.w = transform.quaternion_from_euler(0,0,yaw)
        self.pub_pos.publish(pose)

    def run(self):
        """
        Public Method:  - Main method of the MCL localization class
                        - It starts prediction and update with a rate of 5Hz
                        - It calculates the TF between /odom and /map frame
                        - It visualizes the Particles in RVIZ
                        - It publishes the estimated pose of MCL localization
        """
        rate = rospy.Rate(20) #measurement update with 5Hz
        i = 0
        while not rospy.is_shutdown():
            if self.odometry != None:
                if i == 0: #update with update_rate

                    #predict
                    if self.last_odometry:
                        self.pf.handle_odometry(self.odometry, self.last_odometry)
                    self.last_odometry = self.odometry

                    #capture odom_message and scan_message at same timestamp for TF
                    #odometry_for_tf=self.odometry
                    timestamp = self.observation.header.stamp.to_sec()

                    # measurement update
                    self.pf.handle_observation(self.observation)

                    self.lock.acquire()
                    time_diff = (abs(self.odometry_list_time-timestamp)).copy() # get difference between odom messages and scan message used for calculate particles
                    odometry_for_tf = self.odometry_list[np.argmin(time_diff)] # used odom message with smallest time difference
                    self.odometry_list_time = np.empty(0).copy()
                    self.odometry_list = np.empty(0).copy()
                    self.lock.release()
                    

                    # publish
                    self._update_frame_transformation(odometry_for_tf)
                    self._broadcast_frame_transformation()
                    self._publish()
                    i += 1
                else:
                    self._broadcast_frame_transformation()
                    if i == self.update_rate:
                        i = 0
                    else:
                        i += 1
            rate.sleep()

if __name__ == '__main__':
    mcl = MonteCarloLocalization()
    mcl.run()




