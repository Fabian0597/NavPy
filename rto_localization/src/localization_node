#!/usr/bin/env python3
import rospy
import tf2_ros
import tf.transformations as transform
from std_msgs.msg import ColorRGBA
from nav_msgs.msg import OccupancyGrid, Odometry
from geometry_msgs.msg import TransformStamped
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from math import cos, sin, pi, inf, exp
from threading import Lock
import random
import numpy as np
from matplotlib import pyplot as plt
import ipdb
import sys


from rto_map_server.srv import GetMap

class Particle(object):
    def __init__(self, id, x, y, yaw):
        self.x = x
        self.y = y
        self.id = id
        self.yaw = yaw

class ParticleFilter(object):
    
    # initialize object of ParticleFilter and set all the parameters
    def __init__(self, num_particles, occ_grid_map,
  

                 laser_min_range, laser_max_range, laser_min_angle, laser_max_angle, subsampled_angles, eval_beams, 
                 dynamics_translation_noise_std_dev,
                 dynamics_orientation_noise_std_dev,
                 beam_range_measurement_noise_std_dev):

        #Particle Filter variables
        self.num_particles = num_particles
        self.eval_beams = eval_beams
        self.particles = []
        self.weights = [1/self.num_particles]*self.num_particles

        # Occupancy grid map (self.ogm[x,y])
        self.ogm = occ_grid_map
        self.ogm_map = self.ogm_map = np.transpose(np.asarray(occ_grid_map.map.data, dtype=np.int8).reshape(occ_grid_map.map.info.height, occ_grid_map.map.info.width))
        """
        TODO: the next line transforms all "not seen" cells to occupied cells. The map used for developing MCL is recorded poorly
        obstacles where not completely surrounded with cells 100. To improve the performance i then transformed also the cells within
        an obstacles which were -1 to 100
        """
        self.ogm_map[self.ogm_map==-1]=100

        # Workspace boundaries
        # Occupancy Grid map parameter
        self.xmin = 0
        self.xmax = occ_grid_map.map.info.width-1
        self.ymin = 0
        self.ymax = occ_grid_map.map.info.height-1
        self.resolution = occ_grid_map.map.info.resolution

        # laser setup
        self.laser_max_angle = laser_max_angle
        self.laser_min_angle = laser_min_angle
        self.laser_max_range = laser_max_range
        self.laser_min_range = laser_min_range
        self.subsampled_angles = subsampled_angles

        # Relative motion since the last time particles were updated
        self.dx = 0
        self.dy = 0
        self.dyaw = 0

        # uncertainty for dynamic and sensormodel
        self.dynamics_translation_noise_std_dev = dynamics_translation_noise_std_dev
        self.dynamics_orientation_noise_std_dev = dynamics_orientation_noise_std_dev
        self.beam_range_measurement_noise_std_dev = beam_range_measurement_noise_std_dev

    def ogm_to_map(self, x_ogm, y_ogm, yaw_ogm):
        """
        Transforms map coordinates in the Occupancy Grid Map (coordinate system in bottom left corner of Occupancy Grid Map)
        to coordinates in the "map" coordinates system
        """

        """
        TODO: check if yaw transformation also works in maps where rotation of quaternion is not 0 --> this function is just tested
        in a map where rotation betwwen Occupancy grid map and map coordinate system is 0 and for that it works
        """

        x = x_ogm + self.ogm.map.info.origin.position.x
        y = y_ogm + self.ogm.map.info.origin.position.y
        _, _, yaw_map = transform.euler_from_quaternion(np.array([self.ogm.map.info.origin.orientation.x, self.ogm.map.info.origin.orientation.y, self.ogm.map.info.origin.orientation.z, self.ogm.map.info.origin.orientation.w]))
        yaw = yaw_ogm + yaw_map
        
        return x, y, yaw_ogm
    
    def grid_to_continous(self, x_grid, y_grid):
        """
        Transforms x, y grid postions in continous x, y positions (coordinate system in bottom left corner of map)
        """
        x_continous = x_grid*self.resolution
        y_continous = y_grid*self.resolution
        return x_continous, y_continous

    def _continous_to_grid(self, x_continous, y_continous):
        """
        Transforms continous x, y positions in x, y grid postions (coordinate system in bottom left corner of map)
        """
        grid_x_in_xrange = int(x_continous/self.resolution)
        grid_y_in_yrange = int(y_continous/self.resolution)
        return grid_x_in_xrange, grid_y_in_yrange

    def _get_random_free_space(self):
        """
        samples x,y, yaw positions in the free space of the map close to the init position of robot
        """

        while True:

            x = np.random.uniform(-self.ogm.map.info.origin.position.x*0.99, -self.ogm.map.info.origin.position.x*1.01)
            y = np.random.uniform(-self.ogm.map.info.origin.position.y*0.99, -self.ogm.map.info.origin.position.y*1.01)
            _, _, yaw_map = transform.euler_from_quaternion(np.array([self.ogm.map.info.origin.orientation.x, self.ogm.map.info.origin.orientation.y, self.ogm.map.info.origin.orientation.z, self.ogm.map.info.origin.orientation.w]))
            yaw = np.random.uniform(-yaw_map*0.99, -yaw_map*1.01)
            
            # check if x,y position is not within an obstacle
            x_grid, y_grid = self._continous_to_grid(x,y)
            if self.ogm_map[x_grid, y_grid] != 100:
                break

        return x, y, yaw

    def init_particles(self):
        """
        function which initilizes num_particles of particles
        """
        for i in range(self.num_particles):
            x, y, yaw = self._get_random_free_space()
            particle = Particle(i, x, y, yaw)
            self.particles.append(particle)


    def handle_observation(self, laser_scan_msg):
        """
        prediction and measurement update is started
        """

        weights_not_normalized =[]

        # calculate weights 
        for particle in self.particles:
            particle.x, particle.y, particle.yaw = self._predict_odometry(particle)
            error = self._get_prediction_error(laser_scan_msg, particle)
            weights_not_normalized.append(exp(-error))
        
        #set relative motion by odometry to zero after prediction
        self.dx = 0
        self.dy = 0
        self.dyaw = 0

        # normalize weights
        weights_new = [i/sum(weights_not_normalized) for i in weights_not_normalized]
        self.weights = weights_new.copy()
        #resample
        self._resample()
        

    def _resample(self):
        """
        resample a new set of particles (systematic resampling)
        """

        new_particles = []
        index = random.randint(0,self.num_particles-1)
        max_weight = max(self.weights)
        beta = 0

        for i in range(self.num_particles):
            beta += random.uniform(0, 2*max_weight)

            while self.weights[index] < beta:
                beta -= self.weights[index]

                if (index+1) <= (self.num_particles-1):
                    index += 1
                else:
                    index = 0
      
            particle = self.particles[index]
            new_particle = Particle(i, particle.x, particle.y, particle.yaw)
            new_particles.append(new_particle)

        self.particles = new_particles.copy()

    def get_occupied_cell(self,x,y):
        if x < self.xmin or x > self.xmax or y < self.ymin or y > self.ymax:
            return 200
        elif self.ogm_map[x, y] == 100:
            return 100
        else:
            return 0
        

    def _get_laser_scan_for_particle(self, x, y, yaw):
        """
        simulate what a the robot would sense with laser if it is located in particle pose (x,y,yaw):
            - Take x, y, yaw pose of robot and sense the surrounding in the directions of subsampled angles
            - Start at minimal distance laser_min_range and stop at distance laser_max_range
            - Incrementally go trough all angles and distances and check if there is an obstacle or edge of map
            - This simulates what the robot would sense in the directions of subsampled angles if it is in the pose of the particle
        """

        """
        TODO: if you want to be super precise you can use transform laserscan to base link to improve particles. At the moment the 
        allgorithm is not that precise that this would make huge differences
        """
        #np.set_printoptions(threshold=sys.maxsize)
        particle_ranges = []
        angles = np.array(self.subsampled_angles) + yaw # total angle = angle of robot position + laser angle
        sin_angles = np.sin(angles) # sin values of all angles
        cos_angles = np.cos(angles) # cos valuse of all angles
        distances = np.arange(0,self.laser_max_range, self.resolution)
        
        x_values = np.multiply.outer(distances, cos_angles)+x # observed x_position (distances * cos_angles) --> axis 0 is distances, axis 1 is cosinus of subsampled angles
        y_values = np.multiply.outer(distances, sin_angles)+y # observed y_position (distances * sin_angles) --> axis 0 is distances, axis 1 is sinus of subsampled angles
        assert(x_values.shape==(distances.size,cos_angles.size) and y_values.shape==(distances.size,sin_angles.size))
        
        #transform positions in grid cells
        x_values_grid = (x_values/self.resolution).astype(int) 
        y_values_grid = (y_values/self.resolution).astype(int)
        
        x_values_grid_vector = x_values_grid.flatten() # turn array in vector --> concatenate vectors each containing observed x_position for one distance for all cos_angles
        y_values_grid_vector = y_values_grid.flatten() # turn array in vector --> concatenate vectors each containing observed y_position for one distance for all sin_angles
        assert(x_values_grid_vector.size == distances.size*cos_angles.size and y_values_grid_vector.size == distances.size*sin_angles.size)
        
        # for each x,y position get status of cell (laser_max_range, occupied cell, not occupied cell)
        get_occupied_cell_vectorized = np.vectorize(self.get_occupied_cell) #vectorize function to apply on vectors
        occupied_info_vector = get_occupied_cell_vectorized(x_values_grid_vector, y_values_grid_vector)
        assert(occupied_info_vector.size == distances.size*cos_angles.size)
        
        # reshape  vector as array distances is axis=0 angles is axis=1
        occupied_info_array = occupied_info_vector.reshape(x_values.shape).astype(float)

        # replace all cells which contain obstacles by their distance value (index of axis=0*resolution)
        occupied_info_array[np.where(occupied_info_array==100)]=np.where(occupied_info_array==100)[0]*self.resolution
        # replace all cells which contain distance values smaller than laser_min_range and are not free cells with laser_min_range
        occupied_info_array[(occupied_info_array>0) & (occupied_info_array<=self.laser_min_range)]=self.laser_min_range # replace all distances which are smaller than laser_min_range by laser_min_range
        #replace all cells which are out of map with laser_max_range
        occupied_info_array[occupied_info_array==200]=self.laser_max_range
    
        # go through all angles(axis=1)
        for i in range(occupied_info_array.shape[1]):
            if np.any(occupied_info_array[:,i]==self.laser_min_range): # distances for that angle contain laser_min_range
                particle_ranges.append(self.laser_min_range)
            elif np.all(occupied_info_array[:,i]==0): # no distance for that angle
                particle_ranges.append(self.laser_max_range)
            else: # find smallest distance which contains obstacle and ignore empty cells(distance=0)
                particle_ranges.append(np.min(occupied_info_array[:,i][np.nonzero(occupied_info_array[:,i])]))
        
        return particle_ranges


    def _subsample_laser_scan(self, laser_scan_msg):
        """
        subsample number of beams from output of laser and set inf to laser_max_range:
            -going through the laser_scan_ranges anti-clockwise (index 0 is right behind robot index 245 is left behind robot)
            -from all scans just pick the scans in the direction of subsampled angles (eval_beams number of angles with equal distance to each other)
        
        """
        subsampled_ranges = []
        subsampled_angles_index = np.linspace(0, len(laser_scan_msg.ranges)-1, self.eval_beams).astype(int)
        
        for i in range(self.eval_beams):
            if laser_scan_msg.ranges[subsampled_angles_index[i]] == inf:
                subsampled_ranges.append(self.laser_max_range)
            else:
                subsampled_ranges.append(laser_scan_msg.ranges[subsampled_angles_index[i]])

        return subsampled_ranges

        

    def _get_prediction_error(self, laser_scan_msg, particle):
        """
        calculate error of particle from:
        1) diff in robot scan and particle scan 
        2) position of robot is in free space
        """

        # high error for particles outside of ogm or within an obstacle
        x_grid, y_grid = self._continous_to_grid(particle.x, particle.y)
        if x_grid < self.xmin or x_grid > self.xmax or y_grid < self.ymin or y_grid > self.ymax or (self.ogm_map[x_grid, y_grid] == 100):
            error = 3000
            return error
        else:
            # get robot laser_scan and simulated laser_scan from particle to calculate difference of those
            subsampled_ranges = self._subsample_laser_scan(laser_scan_msg)
            particle_ranges = self._get_laser_scan_for_particle(particle.x, particle.y, particle.yaw)
            diff_ranges = []
            for range_i in range(len(particle_ranges)):
                diff_ranges.append(abs(subsampled_ranges[range_i]-particle_ranges[range_i]))

            # mean squared error from difference in all eval_beams ranges
            norm_error = np.linalg.norm(diff_ranges)
            error = pow(norm_error,2)
            return error
                
    def handle_odometry(self, odom, last_odom):
        """
        calculate relative motion between the last and current odometry measurement
        """

        # last and current position and orientation in numpy array
        position = np.array([odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z])
        last_position = np.array([last_odom.pose.pose.position.x, last_odom.pose.pose.position.y, last_odom.pose.pose.position.z])
        orientation = np.array([odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w])
        last_orientation = np.array([last_odom.pose.pose.orientation.x, last_odom.pose.pose.orientation.y, last_odom.pose.pose.orientation.z, last_odom.pose.pose.orientation.w])
    
        # DIFF YAW: multiplying current orientation with inverse previous orientation and transform quanternion form to euler form of orientation
        #clockwise rotation is negative and anti-clockwise rotation is positive
        diff_orientation_quaternion = transform.quaternion_multiply(transform.quaternion_inverse(last_orientation), orientation)
        _, _, yaw_diff = transform.euler_from_quaternion(diff_orientation_quaternion)

        # DIFF POS
        diff_position = position-last_position
        
        #add relative motion by odometry until it is used to predict the particles
        self.dx += diff_position[0]
        self.dy += diff_position[1]
        self.dyaw += yaw_diff

    def _predict_odometry(self, particle):
        """
        predicts particle according to odometry
        """

        # uncertainty which predicts every particle a little different 
        nx = random.gauss(0, self.dynamics_translation_noise_std_dev)
        ny = random.gauss(0, self.dynamics_translation_noise_std_dev)
        nyaw = random.gauss(0, self.dynamics_orientation_noise_std_dev)

        # don't let uncertainty dominate prdiction (when robot does not move, the uncertainty should not move the particles randomly in space)
        if abs(self.dx) < 0.00005 and abs(self.dy) < 0.00005 and abs(self.dyaw) < 0.00005:
            nx*=0.1
            ny*=0.1
            nyaw*=0.1

        # predict particle according to odometry with a little uncertainty
        x_new = particle.x + self.dx + nx
        y_new = particle.y + self.dy + ny

        if particle.yaw + self.dyaw + nyaw > pi:
            yaw_new = -pi + self.dyaw + nyaw
        elif particle.yaw + self.dyaw + nyaw< -pi:
            yaw_new = pi + self.dyaw + nyaw
        else:
            yaw_new = particle.yaw + self.dyaw + nyaw

        return x_new, y_new, yaw_new

    def get_position(self):
        max_index = np.argmax(self.weights)
        x, y, yaw = self.ogm_to_map(self.particles[max_index].x, self.particles[max_index].y, self.particles[max_index].yaw)
        return x, y, yaw

class MonteCarloLocalization(object):

    #initializes object of MonteCarloLocalization and sets all parameters
    def __init__(self, num_particles):

        rospy.init_node('monte_carlo_localization')

        self.lock = Lock()

        self.count_mcl = 0

        #load map from map_loader_node
        rospy.wait_for_service('get_map')
        try:
            get_map = rospy.ServiceProxy('get_map', GetMap)
            self.ogm = get_map(1)
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)
    
        # set variables for prediction and measurement update
        self.odometry = None
        self.last_odometry = None
        self.eval_beams = 15 

        #read in parameters from launch file
        dynamics_translation_noise_std_dev   = rospy.get_param("~dynamics_translation_noise_std_dev")
        dynamics_orientation_noise_std_dev   = rospy.get_param("~dynamics_orientation_noise_std_dev")
        beam_range_measurement_noise_std_dev = rospy.get_param("~beam_range_measurement_noise_std_dev")

        # instantiate ParticleFilter
        self.pf = ParticleFilter(num_particles, self.ogm, 0, 0, 0, 0, 0, self.eval_beams, 
                                 dynamics_translation_noise_std_dev,
                                 dynamics_orientation_noise_std_dev,
                                 beam_range_measurement_noise_std_dev)

        # initialize particles of pf
        self.pf.init_particles()

        #tf brodcaster
        self.br = tf2_ros.TransformBroadcaster()

        # Subscribers (LaserScan, Odometry)
        self.laser_sub = rospy.Subscriber('/scan', LaserScan, self.laser_scan_callback, queue_size=1) # 40hz
        self.odom_sub = rospy.Subscriber('/odom', Odometry,  self.odometry_callback, queue_size=1) #20hz

        # Publisher (MarkerArray to RVIZ showing all particles, (x,y,yaw) of most probable position)
        self.pub_particles = rospy.Publisher('/particles', MarkerArray, queue_size=1)
        self.pub_best_particle = rospy.Publisher('/particle', Marker, queue_size=1)
    def laser_scan_callback (self, msg):
        # set min and max range, angle of laser
        self.pf.laser_min_angle = msg.angle_min
        self.pf.laser_max_angle = msg.angle_max
        self.pf.laser_min_range = msg.range_min
        self.pf.laser_max_range = msg.range_max

        # set subsampled laserscans
        #angles from start_angle of laser_scan (-2) to end_angle of laser_scan (2)
        subsampled_angles = np.linspace(msg.angle_min, msg.angle_max, self.eval_beams)
        self.pf.subsampled_angles = subsampled_angles

        #measurement update
        self.lock.acquire()
        self.count_mcl += 1

        #just use every count_mcl (second) scan for MCL prediction and update
        if self.count_mcl == 2:
            self.pf.handle_observation(msg)
            self.count_mcl = 0
        self.lock.release()

    def odometry_callback(self, msg):
        self.odometry = msg

        if self.last_odometry:
            # calculate odometry change of robot
            self.lock.acquire()
            self.pf.handle_odometry(self.odometry, self.last_odometry)
            self.lock.release()
        self.last_odometry = self.odometry

    def _publish(self):
        """
        Publish Particles in RVIZ
        """
        # publish all particles in red
        markerArray = MarkerArray()
        for particle in self.pf.particles:
            marker = Marker()
            marker.header.stamp = rospy.Time.now()
            marker.header.frame_id = 'map'
            marker.ns = 'particles'
            marker.id = particle.id
            marker.scale.x = 0.1
            marker.scale.y = 0.1
            marker.type = marker.ARROW  # arrow
            marker.action = 0 # add/modify
            marker.lifetime = rospy.Duration(1)
            marker.color = ColorRGBA(1.0, 0.0, 0, 1.0)
            x_particle, y_particle, yaw_particle = self.pf.ogm_to_map(particle.x, particle.y, particle.yaw)
            marker.pose.position.x, marker.pose.position.y = x_particle, y_particle
            marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w = transform.quaternion_from_euler(0,0,yaw_particle) 
            marker.pose.position.z = 0.0
            markerArray.markers.append(marker)

        # publish the most accurate particle in green
        marker_best = Marker()
        marker_best.header.stamp = rospy.Time.now()
        marker_best.header.frame_id = 'map'
        marker_best.ns = 'particles'
        marker_best.id = 6
        marker_best.scale.x = 0.1
        marker_best.scale.y = 0.1
        marker_best.type = marker_best.ARROW  # arrow
        marker_best.action = 0 # add/modify
        marker_best.lifetime = rospy.Duration(1)
        marker_best.color = ColorRGBA(0.0, 1.0, 0, 1.0)
        x,y,yaw = self.pf.get_position()
        marker_best.pose.position.x, marker_best.pose.position.y = x,y
        marker_best.pose.position.z = 0.0
        marker_best.pose.orientation.x, marker_best.pose.orientation.y, marker_best.pose.orientation.z, marker_best.pose.orientation.w = transform.quaternion_from_euler(0,0,yaw) 
        self.pub_best_particle.publish(marker_best)
        
        self.pub_particles.publish(markerArray)


    def _broadcast_frame_transformation(self):
        # get most likely robot pose from particle filter
            x_Particle_Filter, y_Particle_Filter, yaw_Particle_Filter = self.pf.get_position()
            orientation_particle = transform.quaternion_from_euler(0, 0, yaw_Particle_Filter)

            # get pose from odometry
            x_Odometry = self.odometry.pose.pose.position.x
            y_Odometry = self.odometry.pose.pose.position.y
            orientation_odometry = (self.odometry.pose.pose.orientation.x, self.odometry.pose.pose.orientation.y, self.odometry.pose.pose.orientation.z, self.odometry.pose.pose.orientation.w)

            #calculate diff in pose
            """
            TODO: is the diff calculated in the right way or the other way round?
            """
            x_diff = x_Particle_Filter-x_Odometry
            y_diff = y_Particle_Filter-y_Odometry
            orientation_diff = transform.quaternion_multiply(transform.quaternion_inverse(orientation_odometry), orientation_particle)
            broadcast_msg = TransformStamped()
            broadcast_msg.header.stamp = rospy.Time.now()
            broadcast_msg.header.frame_id = "map"
            broadcast_msg.child_frame_id = "odom"
            broadcast_msg.transform.translation.x = x_diff
            broadcast_msg.transform.translation.y = y_diff
            broadcast_msg.transform.translation.z = 0.0
            broadcast_msg.transform.rotation.x = orientation_diff[0]
            broadcast_msg.transform.rotation.y = orientation_diff[1]
            broadcast_msg.transform.rotation.z = orientation_diff[2]
            broadcast_msg.transform.rotation.w = orientation_diff[3]
            self.br.sendTransform(broadcast_msg)

    

    def run(self):
        rate = rospy.Rate(20)
        while not rospy.is_shutdown():
            if self.odometry != None:
                self._broadcast_frame_transformation()
                self._publish()
            rate.sleep()
    
if __name__ == '__main__':
    num_particles = 100     
    mcl = MonteCarloLocalization(num_particles)
    mcl.run()




