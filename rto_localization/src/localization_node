#!/usr/bin/env python3
import rospy
import tf
import tf.transformations as transform
from std_msgs.msg import String, Header, ColorRGBA
from nav_msgs.msg import OccupancyGrid, MapMetaData, Odometry
from geometry_msgs.msg import Twist, PoseStamped, Point, PointStamped
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from math import sqrt, cos, sin, pi, atan2, inf, log, exp
from threading import Thread, Lock
import random
import numpy as np


from rto_map_server.srv import GetMap

class Particle(object):
    def __init__(self, id, x,y, yaw):
        self.x = x
        self.y = y
        self.id = id
        self.yaw = yaw

class ParticleFilter(object):
    
    # initialize object of ParticleFilter and set all the parameters
    def __init__(self, num_particles, occ_grid_map,
  

                 laser_min_range, laser_max_range, laser_min_angle, laser_max_angle, subsampled_angles, eval_beams, 
                 dynamics_translation_noise_std_dev,
                 dynamics_orientation_noise_std_dev,
                 beam_range_measurement_noise_std_dev):


        self.num_particles = num_particles

        # call a cell in self.ogm by self.ogm[x,y]
        self.ogm = occ_grid_map
        self.ogm_map = self.ogm_map = np.transpose(np.asarray(occ_grid_map.map.data, dtype=np.int8).reshape(occ_grid_map.map.info.width, occ_grid_map.map.info.height))
        
        # Workspace boundaries
        """
        TODO: check if x = width and y = height

        """
        self.xmin = 0
        self.xmax = occ_grid_map.map.info.height-1
        self.ymin = 0
        self.ymax = occ_grid_map.map.info.width-1
        self.resolution = occ_grid_map.map.info.resolution

        # laser setup
        self.laser_max_angle = laser_max_angle
        self.laser_min_angle = laser_min_angle
        self.laser_max_range = laser_max_range
        self.laser_min_range = laser_min_range
        self.subsampled_angles = subsampled_angles


        # Relative motion since the last time particles were updated
        self.dx = 0
        self.dy = 0
        self.dyaw = 0

        #tf Transform
        self.t = tf.Transformer(True, rospy.Duration(10.0))
        self.listener = tf.TransformListener()

        # Std deviation of noise affecting translation in the dynamics model for particles
        self.dynamics_translation_noise_std_dev = dynamics_translation_noise_std_dev

        # Std deviation of noise affecting orientation in the dynamics model for particles
        self.dynamics_orientation_noise_std_dev = dynamics_orientation_noise_std_dev

        # Std deviation of noise affecting measured range from the laser measurement model
        self.beam_range_measurement_noise_std_dev = beam_range_measurement_noise_std_dev

        # Number of laser beams used during the measurement update
        self.eval_beams = eval_beams

        # list of particles and corresponding weights of length num_particles
        self.particles = []
        self.weights = [1]*self.num_particles
    
    def _coordinates_to_grid_transform(self ,x , y):
        """
        transform continous coordinates into valid cell locations in ogm
        """
        grid_x = int(x-self.ogm.map.info.origin.position.x/self.ogm.map.info.resolution)
        grid_y = int(y-self.ogm.map.info.origin.position.y/self.ogm.map.info.resolution)
        grid_x_in_xrange = min(max(0, grid_x), self.xmax)
        grid_y_in_yrange = min(max(0, grid_y), self.ymax)
        return grid_x_in_xrange, grid_y_in_yrange
        
    def grid_to_continous(self, x_grid, y_grid):
        x_continous = x_grid*self.resolution
        y_continous = y_grid*self.resolution
        return x_continous, y_continous

    def continous_to_grid(self, x_continous, y_continous):
        grid_x_in_xrange = int(x_continous/self.resolution)
        grid_y_in_yrange = int(y_continous/self.resolution)
        #grid_x_in_xrange = min(max(0, x_grid), self.xmax)
        #grid_y_in_yrange = min(max(0, y_grid), self.ymax)
        return grid_x_in_xrange, grid_y_in_yrange

    def _get_random_free_space(self):
        """
        randomly samples x,y positions in the free space of the map
        """

        while True:
            x = np.random.randint(self.xmin, self.xmax)
            y = np.random.randint(self.ymin, self.ymax)

            if self.ogm_map[x,y] != 100:
                break

        yaw = np.random.uniform(0,2*pi)
        return x, y, yaw

    def init_particles(self):
        """
        function which initilizes num_particles of particles
        """

        for i in range(self.num_particles):
            x, y, yaw = self._get_random_free_space()
            particle = Particle(i, x, y, yaw)
            self.particles.append(particle)


    def handle_observation(self, laser_scan_msg, dt):
        """
        prediction and measurement update is started
        """

        weights_not_normalized =[]

        for particle in self.particles:
            self.predict_odometry(particle)
            error = self.get_prediction_error(laser_scan_msg, particle)
            weights_not_normalized.append(exp(-error))
        
        self.weights = [i/sum(weights_not_normalized) for i in weights_not_normalized]
        self.resample()

    def resample(self):
        """
        resample a new set of particles (systematic resampling)
        """

        new_particles = []
        index = random.randint(0,self.num_particles-1)
        max_weight = max(self.weights)
        beta = 0

        for i in range(self.num_particles):
            beta += random.uniform(0, 2*max_weight)

            while self.weights[index] < beta:
                beta -= self.weights[index]

                if (index+1) <= (self.num_particles-1):
                    index += 1
                else:
                    index = 0
      
            particle = self.particles[index]
            new_particle = Particle(particle.id, particle.x, particle.y, particle.yaw)
            new_particles.append(new_particle)
        
        self.particles = new_particles


    def get_laser_scan_for_particle(self, x, y, yaw):
        """
        simulate what a the robot would sense with laser if it is located in particle pose (x,y,yaw)
        """

        particle_ranges = []
        step = self.ogm.map.info.resolution

        for i in self.subsampled_angles:
            angle = i+yaw
            distance = self.laser_min_range
            check_if_obstacle_is_sensed = 0

            while distance < self.laser_max_range:
                """
                TODO: check if transformation between grid position and continous position
                """
                x_continous, y_continous = self.grid_to_continous(x,y)
                x_scan = x_continous + cos(angle)*distance
                y_scan = y_continous + sin(angle)*distance
                x_grid, y_grid = self.continous_to_grid(x_scan, y_scan)
                
                """
                TODO:check if when x_scan and y_scan is outside of x_min, x_max, y_min, y_max what would the robot sense? inf?
                """
                if x_grid < self.xmin or x_grid > self.xmax or y_grid < self.ymin or y_grid > self.ymax:
                    particle_ranges.append(self.laser_max_range)
                    check_if_obstacle_is_sensed = 1
                    break
                elif self.ogm_map[x_grid, y_grid] == 100:
                    particle_ranges.append(distance)
                    check_if_obstacle_is_sensed = 1
                    break

                distance += step

            if check_if_obstacle_is_sensed == 0:
                particle_ranges.append(self.laser_max_range)
        rospy.loginfo(particle_ranges)
        return particle_ranges


    def subsample_laser_scan(self, laser_scan_msg):
        """
        subsample number of beams from output of laser and set inf to laser_max_range
        """
        
        subsample_rate = len(laser_scan_msg.ranges)/self.eval_beams
        subsampled_ranges = []

        #pick eval_beams equally distributed in laser_range
        for i in range(self.eval_beams):
            # check if laser_range = inf
            if laser_scan_msg.ranges[int(i*subsample_rate)] == inf:
                subsampled_ranges.append(self.laser_max_range)
            else:
                subsampled_ranges.append(laser_scan_msg.ranges[int(i*subsample_rate)])

        return subsampled_ranges

    def get_prediction_error(self, laser_scan_msg, particle):
        """
        calculate error of particle from:
        1) diff in robot scan and particle scan 
        2) position of robot is in free space
        """
        # high error for particles outside of ogm or within an obstacle
        if particle.x < self.xmin or particle.x > self.xmax or particle.x < self.ymin or particle.y > self.ymax or (self.ogm_map[particle.x, particle.y] == 100):
            error = 300
            return error

        # get robot laser_scan and simulated laser_scan from particle to calculate difference of those
        else:
            subsampled_ranges = self.subsample_laser_scan(laser_scan_msg)
            particle_ranges = self.get_laser_scan_for_particle(particle.x, particle.y, particle.yaw)
            diff_ranges = []

            for range_i in range(len(particle_ranges)):
                diff_ranges.append(abs(subsampled_ranges[range_i]-particle_ranges[range_i]))

            # mean squared error from difference in all eval_beams ranges
            norm_error = np.linalg.norm(diff_ranges)
            error = pow(norm_error,2)
            return error
                
    def handle_odometry(self, odom, last_odom):
        """
        calculate relative motion between the last and current odometry measurement
        """

        # last and current position and orientation in numpy array
        position = np.array([odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z])
        last_position = np.array([last_odom.pose.pose.position.x, last_odom.pose.pose.position.y, last_odom.pose.pose.position.z])
        orientation = np.array([odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w])
        last_orientation = np.array([last_odom.pose.pose.orientation.x, last_odom.pose.pose.orientation.y, last_odom.pose.pose.orientation.z, last_odom.pose.pose.orientation.w])
        
        # multiplying current orientation with inverse previous orientation returns orientation difference in quternion form of orientation
        diff_orientation_quaternion = transform.quaternion_multiply(transform.quaternion_inverse(last_orientation), orientation)

        # transform quatermion form of ortientation to euler form of orientation (roll, pitch, yaw)
        _, _, yaw_diff = transform.euler_from_quaternion(diff_orientation_quaternion)

        diff_position = position-last_position

        self.dx = diff_position[0]
        self.dy = diff_position[1]
        self.dyaw = yaw_diff

    def predict_odometry(self, particle):
        """
        predicts particle according to odometry
        """

        uncertainty_translation = np.random.normal(0, self.dynamics_translation_noise_std_dev)
        uncertainty_orientation = np.random.normal(0, self.dynamics_orientation_noise_std_dev)

        # relative motion with uncertainty
        dx = self.dx + uncertainty_translation
        dy = self.dy + uncertainty_translation
        dyaw = self.dyaw + uncertainty_orientation

        # transform position of particle to position in continous space, add relative motion and transform position of particle back to ogm cell
        particle_x_continous, particle_y_continous= self.grid_to_continous(particle.x, particle.y)
        particle_x_continous_update = particle_x_continous + dx
        particle_y_continous_update = particle_y_continous + dy
        particle.x, particle.y = self.continous_to_grid(particle_x_continous_update, particle_y_continous_update)
        particle.yaw = self.dyaw + uncertainty_orientation

class MonteCarloLocalization(object):

    #initializes object of MonteCarloLocalization and sets all parameters
    def __init__(self, num_particles):

        #initialize ros node
        rospy.init_node('monte_carlo_localization')

        #load map from map_loader_node
        rospy.wait_for_service('get_map')
        try:
            get_map = rospy.ServiceProxy('get_map', GetMap)
            self.ogm = get_map(1)
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)
    
        # set variables
        self.last_laser_scan = None
        self.odometry = None
        self.last_odometry = None
        self.eval_beams = 32

        #read in parameters from launch file
        dynamics_translation_noise_std_dev   = rospy.get_param("~dynamics_translation_noise_std_dev")
        dynamics_orientation_noise_std_dev   = rospy.get_param("~dynamics_orientation_noise_std_dev")
        beam_range_measurement_noise_std_dev = rospy.get_param("~beam_range_measurement_noise_std_dev")

        # instantiate ParticleFilter
        self.pf = ParticleFilter(num_particles, self.ogm, 0, 0, 0, 0, 0, self.eval_beams, 
                                 dynamics_translation_noise_std_dev,
                                 dynamics_orientation_noise_std_dev,
                                 beam_range_measurement_noise_std_dev)

        # initialize particles of pf
        self.pf.init_particles()

        #tf Transform
        self.t = tf.Transformer(True, rospy.Duration(10.0))
        self.listener = tf.TransformListener()

        # Subscribers (LaserScan, Odometry)
        self.laser_sub = rospy.Subscriber('/scan', LaserScan, self.laser_scan_callback, queue_size=1)
        self.odom_sub = rospy.Subscriber('/odom', Odometry,  self.odometry_callback, queue_size=1)

        # Publisher (MarkerArray to RVIZ showing all particles, (x,y,yaw) of most probable position)

    def laser_scan_callback (self, msg):
        self.pf.laser_min_angle = msg.angle_min
        self.pf.laser_max_angle = msg.angle_max
        self.pf.laser_min_range = msg.range_min
        self.pf.laser_max_range = msg.range_max

        """
        TODO: angle_min = -2.0*pi and angle_max = 2.0*pi is dangerous angle_max-angle_min = 4.0 pi = 720 degree
        """
        subsampled_angles = np.linspace(0, msg.angle_max, self.eval_beams)
        self.pf.subsampled_angles = subsampled_angles
        
        if self.last_laser_scan:
            #header.stamp creates a timestamp where it concatinates secs and nsecs. dt is a nsecs value
            dt = msg.header.stamp - self.last_laser_scan.header.stamp
            self.pf.handle_observation(msg,dt)

        self.last_laser_scan = msg

    def odometry_callback(self, msg):
        """
        #transform from frame /odom to frame /base_link
        now = rospy.Time.now()
        self.listener.waitForTransform('/odom', '/base_link', now, rospy.Duration(4.0)) 
        pose_msg = PoseStamped()
        pose_msg.header.frame_id = msg.header.frame_id
        pose_msg.header.stamp = msg.header.stamp
        pose_msg.pose = msg.pose.pose
        self.odometry = self.listener.transformPose('/base_link', pose_msg)
  
        #call handle_odometry
        if self.last_odometry:
            self.pf.handle_odometry(self.odometry, self.last_odometry)
        self.last_odometry = self.odometry
        """
        self.odometry = msg
        if self.last_odometry:
            self.pf.handle_odometry(self.odometry, self.last_odometry)
        self.last_odometry = self.odometry

    def run(self):
        rate = rospy.Rate(20)
        while not rospy.is_shutdown():
            rate.sleep()
    
if __name__ == '__main__':
    num_particles = 50
    mcl = MonteCarloLocalization(num_particles)
    mcl.run()




